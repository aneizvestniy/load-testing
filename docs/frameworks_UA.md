# Фреймворки для load testing — порівняння (фокус: варіативне навантаження + детальні логи + кастомні звіти з response body)

## Коротка рекомендація
**Основний вибір: Grafana k6**
- Найкраще підходить, якщо потрібно:
  - легко **варіювати навантаження** (ramp up/down, stages, arrival-rate)
  - збирати метрики та робити кастомні (в т.ч. на основі полів з response body)
  - мати нормальний шлях до **Grafana** (InfluxDB / Prometheus remote write)
  - генерувати **кастомні репорти** в кінці тесту (JSON/HTML)

**Альтернатива для “багато логіки як у бекенді”: Locust (Python)**
- Коли потрібні складні user flows, багато умов/станів, або дуже кастомні звіти по response body.

**Коли потрібен UI і великий плагін-екосистем: Apache JMeter**
- Підходить командам, які звикли до GUI і “все через конфіг”.

---

## Критерії оцінки (що важливо саме нам)
1) **Load model**: VUs/stages/arrival rate, сценарії, тривалість.
2) **Logs**: детальні логи (status, latency, headers, response), контроль обсягу.
3) **Кастомні репорти**: парсинг response body, доменні метрики, окремий звіт.
4) **CI/CD**: headless запуск, exit codes, артефакти (reports).
5) **Grafana**: реальний час + історія метрик.

---

## 1) Grafana k6 (JavaScript)
### Варіювання навантаження
- Підтримує **stages** (ramp up/down), фіксовані VUs, iterations.
- Є executors зі сценаріями, включно з **arrival-rate** моделями (коли тобі важливий RPS).

### Детальні логи
- Можна логувати у коді (console.log), але це треба робити розумно:
  - логувати тільки **помилки**
  - або робити **sampling** (наприклад, 1% успішних відповідей)
- Для HTTP є debug-режими (корисно для точкового дебагу).

### Кастомні репорти на основі response body
- У k6 можна читати `response.body`, парсити JSON і:
  - інкрементити **custom metrics** (Counter/Trend/Rate)
  - в кінці тесту через `handleSummary(data)` згенерувати:
    - `report.json`
    - `report.html`
    - будь-які додаткові файли (під твій формат)

Важливий практичний момент:
- **Повністю зберігати всі body для всіх запитів** у лоад-тесті — погана ідея (обсяг даних).
- Правильніше: з body витягувати **тільки потрібні поля** → метрики/агрегація.

### Grafana інтеграція
- Найпростіший шлях: **k6 → InfluxDB → Grafana**.
- Альтернатива: **k6 → Prometheus remote write → Grafana** (через extension).

**Плюси:** сучасний DX, легко писати скрипти, сильна Grafana-екосистема.
**Мінуси:** для “повного raw body логування” потрібні обмеження/семплінг.

---

## 2) Locust (Python)
### Варіювання навантаження
- Модель “користувачі + spawn rate”.
- Добре підходить під реалістичні сценарії користувачів.

### Детальні логи
- Повний контроль у Python: можна писати логи, зберігати response body (з обмеженнями), робити власну схему логування.

### Кастомні репорти з response body
- Максимальна свобода: будь-які доменні звіти, агрегації, свої формати.

### Grafana
- Можна інтегрувати (Prometheus/Influx/StatsD), але це більше “підключи сам”, не так out-of-the-box як в k6.

**Плюси:** гнучкість, зручно для складної бізнес-логіки.
**Мінуси:** більше інфраструктурної роботи для метрик/дашбордів.

---

## 3) Apache JMeter
### Варіювання навантаження
- Дуже багато контролерів/таймерів/плагінів.

### Логи + репорти
- Можна логувати responses, але легко “вбити диск”.
- Кастомні репорти з body можливі (extractors + listeners), але часто стає важко підтримувати.

### Grafana
- Типово: Backend Listener → InfluxDB/Graphite → Grafana.

**Плюси:** зрілий, популярний, протоколи.
**Мінуси:** важкий, конфіг-хаос, складні кастомні звіти стають болючими.

---

## 4) Gatling (Scala/Java)
### Варіювання навантаження
- Дуже сильні injection-моделі та продуктивність.

### Репорти
- Хороша статистика, але кастомні репорти з body частіше потребують додаткових налаштувань.

### Grafana
- Зазвичай: InfluxDB/Graphite або Prometheus.

**Плюси:** швидкий, сильний для великих навантажень.
**Мінуси:** Scala-стек і більше “інженерної ваги”, ніж k6.

---

## Практичний вибір під твою вимогу (body-driven report)
Якщо додатковий репорт залежить від вмісту response body (доменні поля), то найзручніше:
1) **k6**: парсимо body → custom metrics + `handleSummary()` → окремий domain report (JSON/HTML/MD).
2) Якщо k6 стане замалий через складні user flows → додати **Locust** для специфічних сценаріїв.
